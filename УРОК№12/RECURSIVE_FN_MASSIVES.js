/* Внутри рекурсивной функции обязательно должно находится условие выхода из рекурсии. Иначе функция будет вызывать саму себя бесконечно. Как только условие выхода выполняется, функция перестает вызывать себя. Чтобы предотвратить бесконечную рекурсию, можно использовать оператор if...else (или аналогичный подход), в котором одна ветвь выполняет рекурсивный вызов, а другая — нет.
В общем случае это выглядит так: */

function recurse() {
    if(условие) {
        recurse();
    }
    else {
        // остановить вызов recurse()
    }
}

recurse();
Пример 1. Выводим числа от n до 1
function countDown(number) {

    // вывод в консоль
    console.log(number);

    // уменьшаем значение на один
    const newNumber = number - 1;

    // условие выхода
    if (newNumber > 0) {
        countDown(newNumber);
    }
}

countDown(4);

// Оператор spread в JS
/* В этой статье вы подробнее познакомитесь с оператором spread в JavaScript. Оператор spread ... появился в версии ES6. Оператор позволяет растягивать массивы. С его помощью обычно копируют или сливают массивы. Например, так: */

const arrValue = ['Меня', 'зовут', 'Евгений', 'Мерк'];
console.log(arrValue);   
console.log(...arrValue); 

/* Копирование массива
Оператор spread ... позволяет копировать элементы в один массив. Например: */

const arr1 = ['один', 'два'];
const arr2 = [...arr1, 'три', 'четыре', 'пять'];
console.log(arr2); 

Клонирование массива
/* В JavaScript объекты присваиваются и копируются по ссылке, а не по значениям. Например: */

let arr1 = [ 1, 2, 3];
let arr2 = arr1;

console.log(arr1); 
console.log(arr2); 

// добавляем элемент в массив
arr1.push(4);

console.log(arr1); 
console.log(arr2); 

/* Обе переменные arr1 и arr2 ссылаются на один и тот же массив. То есть изменение одной переменной приводит к изменению обеих переменных. Однако если вы хотите скопировать массивы так, чтобы они не ссылались на один и тот же массив, вы можете использовать оператор spread. Так изменения в одном массиве не отразятся на другом. Например: */

let arr1 = [ 1, 2, 3];

// копируем с помощью оператора spread
let arr2 = [...arr1];

console.log(arr1); 
console.log(arr2); 

// добавляем элемент в массив
arr1.push(4);
console.log(arr1); 
console.log(arr2); 

//Оператор spread с объектами
/* Оператор spread точно так же работает и с объектами, только вместо элементов работает со свойствами. Например: */

const obj1 = { x : 1, y : 2 };
const obj2 = { z : 3 };

// добавляем свойства obj1 и obj2 в obj3
const obj3 = {...obj1, ...obj2};

console.log(obj3); // Вывод: {x: 1, y: 2, z: 3}
Как вы видите, все свойства объектов obj1 и obj2 стали свойствами объекта obj3.
// Остаточные параметры
/* Когда оператор spread используется в качестве параметра, его называют остаточным параметром (rest parametr). Синтаксис остаточных параметров функции позволяет представлять неограниченное множество аргументов в виде массива. */

let func = function(...args) {
    console.log(args);
}

func(3); 
func(4, 5, 6); 
/* Когда в функцию func() передается 1 аргумент, остаточный параметр принимает только один параметр. Когда в функцию func() передается 3 аргумента, остаточный параметр принимает все три параметра. Примечание. Когда вы используете остаточные параметры, аргумент передаются в функцию в качестве элементов массива. Вы также можете передать в функцию несколько аргументов с помощью оператора spread. Например: */

function sum(x, y ,z) {
    console.log(x + y + z);
}

const num1 = [1, 3, 4, 5];

sum(...num1); 